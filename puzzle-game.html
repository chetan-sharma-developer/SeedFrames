<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Puzzle Game - SeedFrames Engine</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        #game-container {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            background: #000;
        }
        h1 {
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            margin-bottom: 20px;
        }
        .controls {
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>ðŸ§© Puzzle Game</h1>
    <div id="game-container"></div>
    <div class="controls">
        <p><strong>Controls:</strong> Click tiles to move them, arrange them in order</p>
        <p><strong>Goal:</strong> Arrange the numbers from 1 to 8 in order!</p>
    </div>

    <script src="src/seedframes.js"></script>
    <script>
        // Wait for engine to load
        function checkEngine() {
            if (typeof GameEngine !== 'undefined' && GameEngine.SeedFrames) {
                initGame();
            } else {
                setTimeout(checkEngine, 100);
            }
        }

        async function initGame() {
            const engine = new GameEngine.SeedFrames({
                width: 400,
                height: 400,
                containerId: 'game-container',
                backgroundColor: '#F5F5DC',
                debug: true
            });

            // Register SVG assets
            await engine.assetManagement({
                assets: {
                    tile_1: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#FF6B6B" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">1</text>
                        </svg>
                    `),
                    tile_2: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#4ECDC4" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">2</text>
                        </svg>
                    `),
                    tile_3: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#45B7D1" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">3</text>
                        </svg>
                    `),
                    tile_4: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#96CEB4" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">4</text>
                        </svg>
                    `),
                    tile_5: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#FFEAA7" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="#2D3436">5</text>
                        </svg>
                    `),
                    tile_6: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#DDA0DD" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">6</text>
                        </svg>
                    `),
                    tile_7: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#98D8C8" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="white">7</text>
                        </svg>
                    `),
                    tile_8: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#F7DC6F" rx="8"/>
                            <text x="40" y="50" text-anchor="middle" font-size="24" font-weight="bold" fill="#2D3436">8</text>
                        </svg>
                    `),
                    empty_tile: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="80" height="80" viewBox="0 0 80 80">
                            <rect width="80" height="80" fill="#E8E8E8" rx="8" stroke="#CCCCCC" stroke-width="2"/>
                        </svg>
                    `),
                    background: GameEngine.SVG(`
                        <svg xmlns="http://www.w3.org/2000/svg" width="400" height="400" viewBox="0 0 400 400">
                            <rect width="400" height="400" fill="#F5F5DC"/>
                            <rect x="20" y="20" width="360" height="360" fill="#E8E8E8" rx="10"/>
                        </svg>
                    `)
                }
            });

            const scene = new GameEngine.Scene('main');
            engine.sceneManager.add('main', scene);

            // Create background
            scene.createGameObject('Background')
                .at(200, 200)
                .asset('background', 400, 400)
                .build();

            // Puzzle state
            const puzzleSize = 3;
            const tileSize = 80;
            const gap = 10;
            const startX = 60;
            const startY = 60;
            
            let tiles = [];
            let emptyPosition = { x: 2, y: 2 }; // Bottom right corner
            let moves = 0;
            let isComplete = false;

            // Initialize puzzle board
            function initializePuzzle() {
                // Create tiles array with numbers 1-8 and empty space
                const numbers = [1, 2, 3, 4, 5, 6, 7, 8, null];
                
                // Shuffle the numbers
                for (let i = numbers.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [numbers[i], numbers[j]] = [numbers[j], numbers[i]];
                }

                // Create tile game objects
                for (let y = 0; y < puzzleSize; y++) {
                    tiles[y] = [];
                    for (let x = 0; x < puzzleSize; x++) {
                        const number = numbers[y * puzzleSize + x];
                        const tileX = startX + x * (tileSize + gap);
                        const tileY = startY + y * (tileSize + gap);
                        
                        if (number === null) {
                            // Empty tile
                            const emptyTile = scene.createGameObject(`Empty_${x}_${y}`)
                                .at(tileX + tileSize/2, tileY + tileSize/2)
                                .asset('empty_tile', tileSize, tileSize)
                                .withCollider('box', tileSize, tileSize, true, 'Tile')
                                .build();
                            
                            emptyTile.gridX = x;
                            emptyTile.gridY = y;
                            emptyTile.number = null;
                            tiles[y][x] = emptyTile;
                            emptyPosition = { x, y };
                        } else {
                            // Numbered tile
                            const tile = scene.createGameObject(`Tile_${number}`)
                                .at(tileX + tileSize/2, tileY + tileSize/2)
                                .asset(`tile_${number}`, tileSize, tileSize)
                                .withCollider('box', tileSize, tileSize, true, 'Tile')
                                .build();
                            
                            tile.gridX = x;
                            tile.gridY = y;
                            tile.number = number;
                            tile.targetX = tileX + tileSize/2;
                            tile.targetY = tileY + tileSize/2;
                            tiles[y][x] = tile;

                            // Add click handler
                            const collider = tile.getComponent(GameEngine.Collider);
                            collider.onCollisionEnter = (other) => {
                                if (other.name === 'Mouse') {
                                    tryMoveTile(tile);
                                }
                            };
                        }
                    }
                }
            }

            // Try to move a tile
            function tryMoveTile(tile) {
                const dx = Math.abs(tile.gridX - emptyPosition.x);
                const dy = Math.abs(tile.gridY - emptyPosition.y);
                
                // Check if tile is adjacent to empty space
                if ((dx === 1 && dy === 0) || (dx === 0 && dy === 1)) {
                    // Swap positions
                    const oldEmptyX = emptyPosition.x;
                    const oldEmptyY = emptyPosition.y;
                    
                    // Update grid positions
                    tiles[oldEmptyY][oldEmptyX] = tile;
                    tiles[tile.gridY][tile.gridX] = tiles[oldEmptyY][oldEmptyX];
                    
                    // Update tile grid position
                    tile.gridX = oldEmptyX;
                    tile.gridY = oldEmptyY;
                    
                    // Update empty position
                    emptyPosition.x = tile.gridX;
                    emptyPosition.y = tile.gridY;
                    
                    // Animate tile movement
                    const newX = startX + oldEmptyX * (tileSize + gap) + tileSize/2;
                    const newY = startY + oldEmptyY * (tileSize + gap) + tileSize/2;
                    
                    tile.targetX = newX;
                    tile.targetY = newY;
                    
                    moves++;
                    checkWinCondition();
                }
            }

            // Check if puzzle is solved
            function checkWinCondition() {
                let correct = 0;
                for (let y = 0; y < puzzleSize; y++) {
                    for (let x = 0; x < puzzleSize; x++) {
                        const tile = tiles[y][x];
                        const expectedNumber = y * puzzleSize + x + 1;
                        
                        if (x === puzzleSize - 1 && y === puzzleSize - 1) {
                            // Bottom right should be empty
                            if (tile.number === null) correct++;
                        } else if (tile.number === expectedNumber) {
                            correct++;
                        }
                    }
                }
                
                if (correct === puzzleSize * puzzleSize) {
                    isComplete = true;
                    console.log(`Puzzle solved in ${moves} moves!`);
                    setTimeout(() => {
                        alert(`Congratulations! Puzzle solved in ${moves} moves!`);
                        resetPuzzle();
                    }, 500);
                }
            }

            // Reset puzzle
            function resetPuzzle() {
                // Clear existing tiles
                scene.findGameObjectsByName('Tile_').forEach(tile => tile.destroy());
                scene.findGameObjectsByName('Empty_').forEach(tile => tile.destroy());
                
                moves = 0;
                isComplete = false;
                tiles = [];
                
                // Reinitialize
                initializePuzzle();
            }

            // Add UI
            const uiSystem = new GameEngine.UISystem();
            scene.addGameObject(uiSystem);

            const movesText = new GameEngine.UIText('Moves: 0', 20, 20, '#333333', '20px Arial');
            uiSystem.addElement(movesText);

            const resetButton = new GameEngine.UIButton('Reset', 20, 50, 80, 30, '#FF6B6B', '#FFFFFF');
            resetButton.onClick = resetPuzzle;
            uiSystem.addElement(resetButton);

            // Mouse input handling
            const canvas = document.getElementById('game-container').querySelector('canvas');
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;

            canvas.addEventListener('mousedown', (e) => {
                mouseDown = true;
                const rect = canvas.getBoundingClientRect();
                mouseX = e.clientX - rect.left;
                mouseY = e.clientY - rect.top;
                
                // Create temporary mouse object for collision detection
                const mouse = scene.createGameObject('Mouse')
                    .at(mouseX, mouseY)
                    .withCollider('circle', 1, 1, true, 'Mouse')
                    .build();
                
                // Remove after collision check
                setTimeout(() => mouse.destroy(), 10);
            });

            canvas.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            // Game loop update
            scene.update = (deltaTime) => {
                // Animate tile movements
                for (let y = 0; y < puzzleSize; y++) {
                    for (let x = 0; x < puzzleSize; x++) {
                        const tile = tiles[y][x];
                        if (tile && tile.number !== null) {
                            const dx = tile.targetX - tile.transform.position.x;
                            const dy = tile.targetY - tile.transform.position.y;
                            
                            if (Math.abs(dx) > 1 || Math.abs(dy) > 1) {
                                tile.transform.position.x += dx * deltaTime * 5;
                                tile.transform.position.y += dy * deltaTime * 5;
                            } else {
                                tile.transform.position.x = tile.targetX;
                                tile.transform.position.y = tile.targetY;
                            }
                        }
                    }
                }

                // Update UI
                movesText.text = `Moves: ${moves}`;
            };

            // Initialize the puzzle
            initializePuzzle();

            // Load the scene
            engine.sceneManager.load('main');
            
            // Start the engine
            engine.start();
        }

        // Start checking for engine
        checkEngine();
    </script>
</body>
</html>