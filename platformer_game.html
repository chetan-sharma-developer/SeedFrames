<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced SVG Platformer - SeedFrames Engine</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }
        
        #game-container {
            border: 3px solid #333;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            background: #000;
            position: relative;
        }
        
        #ui-overlay {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 100;
            pointer-events: none;
        }
        
        #game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 200;
        }
        
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 100;
        }
        
        .button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }
        
        .button:hover {
            background: #45a049;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="ui-overlay">
            <div>Score: <span id="score">0</span></div>
            <div>Lives: <span id="lives">3</span></div>
            <div>Level: <span id="level">1</span></div>
            <div id="performance-stats" style="display: none;">
                <div>FPS: <span id="fps">0</span></div>
                <div>Objects: <span id="object-count">0</span></div>
                <div>Collisions: <span id="collision-count">0</span></div>
            </div>
        </div>
        
        <div id="game-over-screen">
            <h2>Game Over!</h2>
            <div>Final Score: <span id="final-score">0</span></div>
            <button class="button" onclick="restartGame()">Play Again</button>
        </div>
        
        <div id="instructions">
            Arrow Keys: Move | Spacebar: Jump | X: Double Jump | Z: Dash | R: Restart | M: Toggle Sound | P: Performance Stats
        </div>
        
        <div id="start-prompt" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); 
                                      background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; 
                                      text-align: center; display: none; z-index: 300;">
            <h3>Click to Start Game</h3>
            <p>Audio will be enabled after clicking</p>
        </div>
    </div>

    <script src="./seedframes.js"></script>
    <script>
        // ==================== SVG ASSETS ====================
        
        // SVG Asset Manager for enhanced graphics
        class SVGAssetManager {
            constructor() {
                this.assets = new Map();
                this.loadAssets();
            }
            
            loadAssets() {
                // Player character SVG
                this.assets.set('player', `
                    <svg width="32" height="48" viewBox="0 0 32 48" xmlns="http://www.w3.org/2000/svg">
                        <!-- Body -->
                        <rect x="8" y="16" width="16" height="24" rx="8" fill="#3498db" stroke="#2980b9" stroke-width="2"/>
                        <!-- Head -->
                        <circle cx="16" cy="12" r="8" fill="#f39c12" stroke="#e67e22" stroke-width="2"/>
                        <!-- Eyes -->
                        <circle cx="14" cy="10" r="2" fill="#2c3e50"/>
                        <circle cx="18" cy="10" r="2" fill="#2c3e50"/>
                        <!-- Arms -->
                        <rect x="4" y="20" width="6" height="12" rx="3" fill="#3498db" stroke="#2980b9" stroke-width="1"/>
                        <rect x="22" y="20" width="6" height="12" rx="3" fill="#3498db" stroke="#2980b9" stroke-width="1"/>
                        <!-- Legs -->
                        <rect x="10" y="38" width="4" height="8" rx="2" fill="#34495e" stroke="#2c3e50" stroke-width="1"/>
                        <rect x="18" y="38" width="4" height="8" rx="2" fill="#34495e" stroke="#2c3e50" stroke-width="1"/>
                    </svg>
                `);
                
                // Enemy SVG
                this.assets.set('enemy', `
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <!-- Body -->
                        <rect x="4" y="4" width="16" height="16" rx="8" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>
                        <!-- Eyes -->
                        <circle cx="9" cy="10" r="2" fill="#2c3e50"/>
                        <circle cx="15" cy="10" r="2" fill="#2c3e50"/>
                        <!-- Mouth -->
                        <path d="M 8 16 Q 12 20 16 16" stroke="#2c3e50" stroke-width="2" fill="none"/>
                        <!-- Spikes -->
                        <polygon points="12,2 14,6 10,6" fill="#c0392b"/>
                        <polygon points="12,22 14,18 10,18" fill="#c0392b"/>
                        <polygon points="2,12 6,14 6,10" fill="#c0392b"/>
                        <polygon points="22,12 18,14 18,10" fill="#c0392b"/>
                    </svg>
                `);
                
                // Platform SVG
                this.assets.set('platform', `
                    <svg width="200" height="40" viewBox="0 0 200 40" xmlns="http://www.w3.org/2000/svg">
                        <!-- Main platform -->
                        <rect x="0" y="0" width="200" height="40" fill="#34495e" stroke="#2c3e50" stroke-width="2"/>
                        <!-- Grass top -->
                        <rect x="0" y="0" width="200" height="8" fill="#27ae60" stroke="#229954" stroke-width="1"/>
                        <!-- Grass details -->
                        <circle cx="20" cy="4" r="2" fill="#2ecc71"/>
                        <circle cx="60" cy="6" r="1.5" fill="#2ecc71"/>
                        <circle cx="100" cy="3" r="2.5" fill="#2ecc71"/>
                        <circle cx="140" cy="5" r="1" fill="#2ecc71"/>
                        <circle cx="180" cy="4" r="2" fill="#2ecc71"/>
                        <!-- Wood texture -->
                        <line x1="0" y1="12" x2="200" y2="12" stroke="#2c3e50" stroke-width="1"/>
                        <line x1="0" y1="20" x2="200" y2="20" stroke="#2c3e50" stroke-width="1"/>
                        <line x1="0" y1="28" x2="200" y2="28" stroke="#2c3e50" stroke-width="1"/>
                        <line x1="0" y1="36" x2="200" y2="36" stroke="#2c3e50" stroke-width="1"/>
                    </svg>
                `);
                
                // Moving platform SVG
                this.assets.set('moving-platform', `
                    <svg width="100" height="60" viewBox="0 0 100 60" xmlns="http://www.w3.org/2000/svg">
                        <!-- Main platform -->
                        <rect x="0" y="0" width="100" height="60" fill="#9b59b6" stroke="#8e44ad" stroke-width="2"/>
                        <!-- Magical glow -->
                        <rect x="0" y="0" width="100" height="60" fill="url(#magicalGradient)" opacity="0.3"/>
                        <!-- Crystals -->
                        <polygon points="20,10 25,20 15,20" fill="#e74c3c"/>
                        <polygon points="50,15 55,25 45,25" fill="#3498db"/>
                        <polygon points="80,12 85,22 75,22" fill="#f1c40f"/>
                        <!-- Gear mechanism -->
                        <circle cx="20" cy="45" r="8" fill="#34495e" stroke="#2c3e50" stroke-width="2"/>
                        <circle cx="80" cy="45" r="8" fill="#34495e" stroke="#2c3e50" stroke-width="2"/>
                        <rect x="18" y="43" width="4" height="4" fill="#ecf0f1"/>
                        <rect x="78" y="43" width="4" height="4" fill="#ecf0f1"/>
                        
                        <defs>
                            <linearGradient id="magicalGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                <stop offset="0%" style="stop-color:#9b59b6;stop-opacity:1" />
                                <stop offset="50%" style="stop-color:#e74c3c;stop-opacity:1" />
                                <stop offset="100%" style="stop-color:#3498db;stop-opacity:1" />
                            </linearGradient>
                        </defs>
                    </svg>
                `);
                
                // Coin SVG
                this.assets.set('coin', `
                    <svg width="20" height="20" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                        <!-- Coin body -->
                        <circle cx="10" cy="10" r="8" fill="#f1c40f" stroke="#f39c12" stroke-width="2"/>
                        <!-- Inner design -->
                        <circle cx="10" cy="10" r="4" fill="#f39c12"/>
                        <!-- Dollar sign -->
                        <text x="10" y="13" text-anchor="middle" font-size="6" font-weight="bold" fill="#ffffff">$</text>
                        <!-- Shine effect -->
                        <ellipse cx="7" cy="7" rx="2" ry="1" fill="#ffffff" opacity="0.8"/>
                    </svg>
                `);
                
                // Gem SVG
                this.assets.set('gem', `
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <!-- Gem shape -->
                        <polygon points="12,2 18,8 12,22 6,8" fill="#e74c3c" stroke="#c0392b" stroke-width="2"/>
                        <!-- Inner facets -->
                        <polygon points="12,4 16,8 12,20 8,8" fill="#ff6b6b"/>
                        <polygon points="12,6 14,8 12,18 10,8" fill="#ff8e8e"/>
                        <!-- Shine effect -->
                        <polygon points="10,6 12,8 10,10" fill="#ffffff" opacity="0.6"/>
                        <polygon points="14,6 16,8 14,10" fill="#ffffff" opacity="0.6"/>
                    </svg>
                `);
                
                // Hazard SVG
                this.assets.set('hazard', `
                    <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <!-- Spikes -->
                        <polygon points="12,2 20,18 16,18 12,10 8,18 4,18" fill="#e74c3c" stroke="#c0392b" stroke-width="1"/>
                        <!-- Base -->
                        <rect x="8" y="18" width="8" height="6" fill="#34495e" stroke="#2c3e50" stroke-width="1"/>
                        <!-- Warning stripes -->
                        <rect x="10" y="20" width="4" height="2" fill="#f39c12"/>
                        <rect x="10" y="22" width="4" height="2" fill="#e74c3c"/>
                    </svg>
                `);
                
                // Background elements
                this.assets.set('tree', `
                    <svg width="40" height="60" viewBox="0 0 40 60" xmlns="http://www.w3.org/2000/svg">
                        <!-- Trunk -->
                        <rect x="15" y="40" width="10" height="20" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                        <!-- Leaves -->
                        <circle cx="20" cy="25" r="15" fill="#228B22" stroke="#006400" stroke-width="2"/>
                        <circle cx="15" cy="20" r="8" fill="#32CD32"/>
                        <circle cx="25" cy="30" r="10" fill="#228B22"/>
                        <!-- Highlights -->
                        <circle cx="18" cy="22" r="3" fill="#90EE90" opacity="0.6"/>
                    </svg>
                `);
                
                this.assets.set('cloud', `
                    <svg width="80" height="40" viewBox="0 0 80 40" xmlns="http://www.w3.org/2000/svg">
                        <!-- Cloud shape -->
                        <ellipse cx="20" cy="20" rx="15" ry="12" fill="#ffffff" opacity="0.8"/>
                        <ellipse cx="35" cy="15" rx="12" ry="10" fill="#ffffff" opacity="0.8"/>
                        <ellipse cx="50" cy="20" rx="18" ry="14" fill="#ffffff" opacity="0.8"/>
                        <ellipse cx="65" cy="18" rx="10" ry="8" fill="#ffffff" opacity="0.8"/>
                        <!-- Shading -->
                        <ellipse cx="25" cy="18" rx="8" ry="6" fill="#f0f0f0" opacity="0.5"/>
                    </svg>
                `);
                
                this.assets.set('mountain', `
                    <svg width="120" height="80" viewBox="0 0 120 80" xmlns="http://www.w3.org/2000/svg">
                        <!-- Mountain peaks -->
                        <polygon points="0,80 30,40 60,60 90,20 120,80" fill="#8B4513" stroke="#654321" stroke-width="1"/>
                        <!-- Snow caps -->
                        <polygon points="25,45 30,40 35,45" fill="#ffffff"/>
                        <polygon points="85,25 90,20 95,25" fill="#ffffff"/>
                        <!-- Shading -->
                        <polygon points="0,80 30,40 30,80" fill="#654321" opacity="0.3"/>
                        <polygon points="90,20 120,80 90,80" fill="#654321" opacity="0.3"/>
                    </svg>
                `);
                
                // Additional decorative elements
                this.assets.set('flower', `
                    <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
                        <!-- Petals -->
                        <circle cx="8" cy="8" r="6" fill="#ff69b4" stroke="#ff1493" stroke-width="1"/>
                        <circle cx="8" cy="8" r="4" fill="#ffb6c1"/>
                        <!-- Center -->
                        <circle cx="8" cy="8" r="2" fill="#ffff00"/>
                        <!-- Stem -->
                        <line x1="8" y1="14" x2="8" y2="16" stroke="#228b22" stroke-width="2"/>
                    </svg>
                `);
                
                this.assets.set('bush', `
                    <svg width="24" height="16" viewBox="0 0 24 16" xmlns="http://www.w3.org/2000/svg">
                        <!-- Bush shape -->
                        <ellipse cx="12" cy="8" rx="10" ry="6" fill="#228b22" stroke="#006400" stroke-width="1"/>
                        <ellipse cx="8" cy="6" rx="4" ry="3" fill="#32cd32"/>
                        <ellipse cx="16" cy="6" rx="4" ry="3" fill="#32cd32"/>
                        <ellipse cx="12" cy="4" rx="3" ry="2" fill="#90ee90"/>
                    </svg>
                `);
            }
            
            getAsset(name) {
                return this.assets.get(name) || '';
            }
            
            createImageFromSVG(svgString, width, height) {
                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                
                const img = new Image();
                const svgBlob = new Blob([svgString], {type: 'image/svg+xml'});
                const url = URL.createObjectURL(svgBlob);
                
                return new Promise((resolve) => {
                    img.onload = () => {
                        ctx.drawImage(img, 0, 0, width, height);
                        URL.revokeObjectURL(url);
                        resolve(canvas);
                    };
                    img.src = url;
                });
            }
        }
        
        // Enhanced SVG Sprite Renderer
        class SVGSpriteRenderer extends GameEngine.SpriteRenderer {
            constructor(svgAsset, width, height, config = {}) {
                super(config);
                this.svgAsset = svgAsset;
                this.width = width;
                this.height = height;
                this.svgManager = new SVGAssetManager();
                this.canvas = null;
                this.loadSVG();
            }
            
            async loadSVG() {
                const svgString = this.svgManager.getAsset(this.svgAsset);
                if (svgString) {
                    this.canvas = await this.svgManager.createImageFromSVG(svgString, this.width, this.height);
                }
            }
            
            draw(ctx) {
                if (!this.canvas || !this.enabled) return;
                
                ctx.save();
                
                // Apply transformations
                if (this.gameObject && this.gameObject.transform) {
                    const pos = this.gameObject.transform.position;
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(this.gameObject.transform.rotation);
                    ctx.scale(this.gameObject.transform.scale.x, this.gameObject.transform.scale.y);
                }
                
                // Apply alpha
                ctx.globalAlpha = this.alpha;
                
                // Draw the SVG canvas
                ctx.drawImage(this.canvas, -this.width / 2, -this.height / 2, this.width, this.height);
                
                ctx.restore();
            }
        }
        
        // Global SVG asset manager
        const svgAssetManager = new SVGAssetManager();

        // ==================== GAME STATE ====================
        let gameState = {
            score: 0,
            lives: 3,
            level: 1,
            gameOver: false,
            playerStartX: 100,
            playerStartY: 400,
            maxLevel: 3
        };

        // ==================== AUDIO SYSTEM ====================
        class AudioManager {
            constructor() {
                this.context = null;
                this.sounds = {};
                this.enabled = true;
                this.masterVolume = 0.3;
                this.initAudio();
            }

            initAudio() {
                // Delay audio context creation until user interaction
                this.enabled = true;
            }
            
            createAudioContext() {
                if (this.context) return;
                
                try {
                    this.context = new (window.AudioContext || window.webkitAudioContext)();
                    this.createSounds();
                    console.log('Audio system initialized');
                } catch (e) {
                    console.warn('Web Audio API not supported');
                    this.enabled = false;
                }
            }

            createSounds() {
                // Create programmatic sound effects
                this.sounds.jump = this.createTone(800, 0.1, 'square');
                this.sounds.collect = this.createTone(1200, 0.15, 'sine');
                this.sounds.damage = this.createNoiseSound(0.3);
                this.sounds.dash = this.createSweepTone(400, 800, 0.1);
                this.sounds.enemy_hit = this.createTone(200, 0.2, 'sawtooth');
            }

            createTone(frequency, duration, type = 'sine') {
                return () => {
                    if (!this.enabled || !this.context) return;
                    
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0, this.context.currentTime);
                    gainNode.gain.linearRampToValueAtTime(this.masterVolume * 0.1, this.context.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                    
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + duration);
                };
            }

            createSweepTone(startFreq, endFreq, duration) {
                return () => {
                    if (!this.enabled || !this.context) return;
                    
                    const oscillator = this.context.createOscillator();
                    const gainNode = this.context.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    oscillator.frequency.setValueAtTime(startFreq, this.context.currentTime);
                    oscillator.frequency.linearRampToValueAtTime(endFreq, this.context.currentTime + duration);
                    oscillator.type = 'square';
                    
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.15, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                    
                    oscillator.start(this.context.currentTime);
                    oscillator.stop(this.context.currentTime + duration);
                };
            }

            createNoiseSound(duration) {
                return () => {
                    if (!this.enabled || !this.context) return;
                    
                    const bufferSize = this.context.sampleRate * duration;
                    const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
                    const output = buffer.getChannelData(0);
                    
                    for (let i = 0; i < bufferSize; i++) {
                        output[i] = Math.random() * 2 - 1;
                    }
                    
                    const whiteNoise = this.context.createBufferSource();
                    const gainNode = this.context.createGain();
                    
                    whiteNoise.buffer = buffer;
                    whiteNoise.connect(gainNode);
                    gainNode.connect(this.context.destination);
                    
                    gainNode.gain.setValueAtTime(this.masterVolume * 0.1, this.context.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + duration);
                    
                    whiteNoise.start(this.context.currentTime);
                };
            }

            play(soundName) {
                if (!this.enabled) return;
                
                // Create audio context on first play (user interaction)
                if (!this.context) {
                    this.createAudioContext();
                }
                
                if (this.sounds[soundName] && this.context) {
                    this.sounds[soundName]();
                }
            }

            setVolume(volume) {
                this.masterVolume = Math.max(0, Math.min(1, volume));
            }

            toggle() {
                this.enabled = !this.enabled;
                return this.enabled;
            }
        }

        const audioManager = new AudioManager();

        // ==================== GAME INITIALIZATION ====================
        const engine = new GameEngine.SeedFrames({
            width: 1000,
            height: 600,
            containerId: 'game-container',
            backgroundColor: '#87CEEB',
            debug: false
        });

        // ==================== SCENES ====================
        const gameScene = engine.createScene('GameScene');
        let player, camera;
        let platforms = [];
        let enemies = [];
        let collectibles = [];
        let hazards = [];
        let particles = [];

        // ==================== CUSTOM COMPONENTS ====================
        
        // Enhanced Player Component with Advanced Platformer Features
        class AdvancedPlatformerPlayer extends GameEngine.PlatformerPlayer {
            constructor(config = {}) {
                super({
                    speed: 250,
                    jumpForce: 500,
                    gravity: 1200,
                    coyoteTime: 0.15,
                    jumpBufferTime: 0.1,
                    maxFallSpeed: 800,
                    ...config
                });
                
                this.doubleJumpAvailable = true;
                this.dashAvailable = true;
                this.dashCooldown = 0;
                this.dashForce = 400;
                this.invulnerable = false;
                this.invulnerabilityTime = 0;
                this.animationState = 'idle';
                this.facingDirection = 1;
                
                // Physics control flags
                this.controlVelocity = true;
                this.groundedCheckTimer = 0;
            }

            update(deltaTime) {
                // Call parent update (handles input and basic physics)
                super.update(deltaTime);
                
                // Handle invulnerability
                if (this.invulnerable) {
                    this.invulnerabilityTime -= deltaTime;
                    if (this.invulnerabilityTime <= 0) {
                        this.invulnerable = false;
                        const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                        if (renderer) renderer.alpha = 1.0;
                    } else {
                        // Flashing effect
                        const flash = Math.sin(this.invulnerabilityTime * 20) > 0;
                        const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                        if (renderer) renderer.alpha = flash ? 0.3 : 1.0;
                    }
                }
                
                // Handle dash cooldown
                if (this.dashCooldown > 0) {
                    this.dashCooldown -= deltaTime;
                }
                
                // Update facing direction and animation
                this.updateFacingDirection();
                this.updateAnimationState();
                
                // Check boundaries
                this.checkBoundaries();
            }
            
            // Override handlePlatformerInput to add advanced features
            handlePlatformerInput(deltaTime) {
                // Call parent method for basic platformer input
                super.handlePlatformerInput(deltaTime);
                
                // Add double jump
                if (engine.inputManager.isKeyPressed('KeyX') && this.doubleJumpAvailable && !this.isGrounded) {
                    const currentVelocity = this.rigidbody.velocity;
                    this.rigidbody.setVelocity(new Vector2(currentVelocity.x, -this.jumpForce * 0.8));
                    this.doubleJumpAvailable = false;
                    createJumpParticles(this.gameObject.transform.position);
                    audioManager.play('jump');
                }
                
                // Add dash ability
                if (engine.inputManager.isKeyPressed('KeyZ') && this.dashAvailable && this.dashCooldown <= 0) {
                    const currentVelocity = this.rigidbody.velocity;
                    this.rigidbody.setVelocity(new Vector2(this.facingDirection * this.dashForce, currentVelocity.y));
                    this.dashCooldown = 1.0;
                    createDashParticles(this.gameObject.transform.position);
                    audioManager.play('dash');
                }
                
                // Reset double jump when grounded
                if (this.isGrounded) {
                    this.doubleJumpAvailable = true;
                }
            }
            
            jump() {
                const rigidbody = this.gameObject.getComponent(GameEngine.Rigidbody);
                if (!rigidbody) return;
                
                rigidbody.velocity.y = -this.jumpForce;
                this.isGrounded = false;
                this.lastGroundedTime = this.coyoteTime + 0.1;
                
                if (this.onJump) this.onJump();
            }
            
            updateFacingDirection() {
                if (!this.rigidbody) return;
                
                if (this.rigidbody.velocity.x > 10) this.facingDirection = 1;
                else if (this.rigidbody.velocity.x < -10) this.facingDirection = -1;
            }
            
            updateAnimationState() {
                const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                if (!renderer || !this.rigidbody) return;
                
                if (!this.isGrounded) {
                    this.animationState = 'jumping';
                    renderer.color = '#4a90e2';
                } else if (Math.abs(this.rigidbody.velocity.x) > 10) {
                    this.animationState = 'running';
                    renderer.color = '#2ecc71';
                } else {
                    this.animationState = 'idle';
                    renderer.color = '#3498db';
                }
            }
            
            updateGroundedState() {
                const rigidbody = this.gameObject.getComponent(GameEngine.Rigidbody);
                if (!rigidbody) return;
                
                // Check if we're moving downward slowly (indicating we're on ground)
                if (rigidbody.velocity.y >= -5 && rigidbody.velocity.y <= 5) {
                    // We're not falling fast, might be grounded
                    if (this.lastGroundedTime < 0.1) {
                        this.isGrounded = true;
                    }
                } else {
                    // We're falling or jumping, not grounded
                    this.isGrounded = false;
                }
            }
            
            checkBoundaries() {
                const pos = this.gameObject.transform.position;
                
                // Fall off the bottom = lose life
                if (pos.y > 700) {
                    this.takeDamage();
                }
                
                // Keep player in horizontal bounds
                if (pos.x < -50) {
                    this.gameObject.transform.position.x = -50;
                    if (this.rigidbody) {
                        this.rigidbody.setVelocity(new Vector2(0, this.rigidbody.velocity.y));
                    }
                }
            }
            
            takeDamage() {
                if (this.invulnerable) return;
                
                gameState.lives--;
                updateUI();
                
                if (gameState.lives <= 0) {
                    endGame();
                } else {
                    this.respawnPlayer();
                    this.invulnerable = true;
                    this.invulnerabilityTime = 2.0;
                }
                
                createExplosionParticles(this.gameObject.transform.position);
                audioManager.play('damage');
            }
            
            respawnPlayer() {
                this.gameObject.transform.position = new GameEngine.Vector2(gameState.playerStartX, gameState.playerStartY);
                
                // Reset Rigidbody velocity
                if (this.rigidbody) {
                    this.rigidbody.setVelocity(new GameEngine.Vector2(0, 0));
                }
                
                this.doubleJumpAvailable = true;
                this.dashCooldown = 0;
                this.isGrounded = false;
                this.lastGroundedTime = 0;
            }
            
            onCollisionEnter(other) {
                // Call parent method to handle platform collisions
                super.onCollisionEnter(other);
                
                const otherCollider = other.getComponent(GameEngine.Collider);
                if (!otherCollider) return;
                

                
                // Handle enemy collisions
                if (otherCollider.layer === 'Enemy') {
                    if (!this.invulnerable) {
                        this.takeDamage();
                    }
                }
                
                // Handle hazard collisions
                if (otherCollider.layer === 'Hazard') {
                    if (!this.invulnerable) {
                        this.takeDamage();
                    }
                }
            }
            
            onCollisionExit(other) {
                // Call parent method to handle platform collision exit
                super.onCollisionExit(other);
            }
        }

        // Moving Platform Component
        class MovingPlatform extends GameEngine.Component {
            constructor(speed = 100, distance = 50, direction = 'horizontal') {
                super();
                this.speed = speed;
                this.distance = distance;
                this.direction = direction;
                this.startPosition = null;
                this.time = 0;
            }
            
            start() {
                this.startPosition = this.gameObject.transform.position.copy();
            }
            
            update(deltaTime) {
                if (!this.startPosition) return;
                
                this.time += deltaTime;
                const t = (Math.sin(this.time * this.speed * 0.01) + 1) / 2; // 0 to 1
                
                if (this.direction === 'horizontal') {
                    this.gameObject.transform.position.x = this.startPosition.x + t * this.distance;
                } else if (this.direction === 'vertical') {
                    this.gameObject.transform.position.y = this.startPosition.y + t * this.distance;
                }
            }
        }

        // Enemy AI Component
        class EnemyAI extends GameEngine.Component {
            constructor(type = 'patrol', speed = 100) {
                super();
                this.type = type;
                this.speed = speed;
                this.direction = 1;
                this.detectionRange = 150;
                this.patrolDistance = 100;
                this.startX = 0;
                this.health = 1;
            }
            
            start() {
                this.startX = this.gameObject.transform.position.x;
                this.player = gameScene.findGameObjectWithComponent(AdvancedPlatformerPlayer);
            }
            
            update(deltaTime) {
                switch (this.type) {
                    case 'patrol':
                        this.patrolBehavior(deltaTime);
                        break;
                    case 'chase':
                        this.chaseBehavior(deltaTime);
                        break;
                    case 'jump':
                        this.jumpBehavior(deltaTime);
                        break;
                }
                
                this.updateVisuals();
            }
            
            patrolBehavior(deltaTime) {
                const pos = this.gameObject.transform.position;
                const movement = this.speed * this.direction * deltaTime;
                
                // Check patrol boundaries
                if (pos.x >= this.startX + this.patrolDistance || pos.x <= this.startX - this.patrolDistance) {
                    this.direction *= -1;
                }
                
                pos.x += movement;
            }
            
            chaseBehavior(deltaTime) {
                if (!this.player) return;
                
                const pos = this.gameObject.transform.position;
                const playerPos = this.player.transform.position;
                const distance = pos.distance(playerPos);
                
                if (distance < this.detectionRange) {
                    const direction = playerPos.x > pos.x ? 1 : -1;
                    pos.x += this.speed * direction * deltaTime;
                    this.direction = direction;
                }
            }
            
            jumpBehavior(deltaTime) {
                const rigidbody = this.gameObject.getComponent(GameEngine.Rigidbody);
                if (rigidbody && Math.random() < 0.01) { // Random jump chance
                    rigidbody.velocity.y = -300;
                }
                this.patrolBehavior(deltaTime);
            }
            
            updateVisuals() {
                const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                if (renderer) {
                    // Simple color-based animation
                    const time = Date.now() * 0.005;
                    const brightness = 0.5 + 0.3 * Math.sin(time);
                    renderer.color = `hsl(0, 70%, ${brightness * 100}%)`;
                }
            }
            
            onCollisionEnter(other) {
                const playerComponent = other.getComponent(AdvancedPlatformerPlayer);
                if (playerComponent) {
                    playerComponent.takeDamage();
                }
            }
            
            takeDamage() {
                this.health--;
                if (this.health <= 0) {
                    gameState.score += 100;
                    updateUI();
                    createExplosionParticles(this.gameObject.transform.position);
                    audioManager.play('enemy_hit');
                    this.gameObject.destroy();
                }
            }
        }

        // Collectible Component
        class Collectible extends GameEngine.Component {
            constructor(value = 50, type = 'coin') {
                super();
                this.value = value;
                this.type = type;
                this.collected = false;
                this.bobOffset = Math.random() * Math.PI * 2;
                this.startY = 0;
            }
            
            start() {
                this.startY = this.gameObject.transform.position.y;
            }
            
            update(deltaTime) {
                if (this.collected) return;
                
                // Bobbing animation
                const time = Date.now() * 0.003;
                this.gameObject.transform.position.y = this.startY + Math.sin(time + this.bobOffset) * 5;
                
                // Rotating color effect
                const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                if (renderer) {
                    const hue = (time * 50 + this.bobOffset * 50) % 360;
                    renderer.color = `hsl(${hue}, 80%, 60%)`;
                }
            }
            
            onCollisionEnter(other) {
                if (this.collected) return;
                
                const playerComponent = other.getComponent(AdvancedPlatformerPlayer);
                if (playerComponent) {
                    this.collected = true;
                    gameState.score += this.value;
                    updateUI();
                    
                    createCollectParticles(this.gameObject.transform.position);
                    audioManager.play('collect');
                    this.gameObject.destroy();
                    
                    // Check if all collectibles collected
                    checkLevelComplete();
                }
            }
        }



        // ==================== PARTICLE EFFECTS ====================
        
        function createJumpParticles(position) {
            for (let i = 0; i < 8; i++) {
                const particle = gameScene.createGameObject(`JumpParticle_${Date.now()}_${i}`)
                    .at(position.x + (Math.random() - 0.5) * 20, position.y + 20)
                    .withColor('#ffffff', 4, 4)
                    .build();
                    
                const particleComponent = particle.addComponent(new SimpleParticle(
                    new GameEngine.Vector2((Math.random() - 0.5) * 200, -Math.random() * 100),
                    1.0
                ));
            }
        }
        
        function createDashParticles(position) {
            for (let i = 0; i < 12; i++) {
                const particle = gameScene.createGameObject(`DashParticle_${Date.now()}_${i}`)
                    .at(position.x, position.y)
                    .withColor('#00ffff', 6, 6)
                    .build();
                    
                const particleComponent = particle.addComponent(new SimpleParticle(
                    new GameEngine.Vector2((Math.random() - 0.5) * 300, (Math.random() - 0.5) * 200),
                    0.8
                ));
            }
        }
        
        function createCollectParticles(position) {
            for (let i = 0; i < 10; i++) {
                const particle = gameScene.createGameObject(`CollectParticle_${Date.now()}_${i}`)
                    .at(position.x, position.y)
                    .withColor('#ffd700', 3, 3)
                    .build();
                    
                const particleComponent = particle.addComponent(new SimpleParticle(
                    new GameEngine.Vector2((Math.random() - 0.5) * 150, -Math.random() * 200),
                    1.2
                ));
            }
        }
        
        function createExplosionParticles(position) {
            for (let i = 0; i < 15; i++) {
                const particle = gameScene.createGameObject(`ExplosionParticle_${Date.now()}_${i}`)
                    .at(position.x, position.y)
                    .withColor('#ff4444', 8, 8)
                    .build();
                    
                const particleComponent = particle.addComponent(new SimpleParticle(
                    new GameEngine.Vector2((Math.random() - 0.5) * 300, (Math.random() - 0.5) * 300),
                    0.6
                ));
            }
        }

        // Simple Particle Component
        class SimpleParticle extends GameEngine.Component {
            constructor(velocity, lifetime) {
                super();
                this.velocity = velocity;
                this.lifetime = lifetime;
                this.maxLifetime = lifetime;
                this.gravity = 500;
            }
            
            update(deltaTime) {
                this.lifetime -= deltaTime;
                
                if (this.lifetime <= 0) {
                    this.gameObject.destroy();
                    return;
                }
                
                // Apply gravity
                this.velocity.y += this.gravity * deltaTime;
                
                // Move particle
                const pos = this.gameObject.transform.position;
                pos.x += this.velocity.x * deltaTime;
                pos.y += this.velocity.y * deltaTime;
                
                // Fade out
                const renderer = this.gameObject.getComponent(GameEngine.SpriteRenderer);
                if (renderer) {
                    renderer.alpha = this.lifetime / this.maxLifetime;
                }
            }
        }

        // ==================== LEVEL CREATION ====================
        
        function createLevel(levelNumber) {
            // Clear existing level
            clearLevel();
            
            // Reset player position
            gameState.playerStartX = 100;
            gameState.playerStartY = 400;
            
            switch (levelNumber) {
                case 1:
                    createLevel1();
                    break;
                case 2:
                    createLevel2();
                    break;
                case 3:
                    createLevel3();
                    break;
                default:
                    createLevel1();
            }
        }
        
        function createBackgroundElements() {
            // Create background elements for visual appeal
            const backgroundElements = [
                { type: 'mountain', x: 50, y: 400, scale: 0.8 },
                { type: 'mountain', x: 300, y: 380, scale: 0.6 },
                { type: 'mountain', x: 600, y: 420, scale: 0.7 },
                { type: 'tree', x: 150, y: 480, scale: 0.9 },
                { type: 'tree', x: 450, y: 500, scale: 0.8 },
                { type: 'tree', x: 750, y: 490, scale: 0.7 },
                { type: 'cloud', x: 100, y: 100, scale: 0.6 },
                { type: 'cloud', x: 400, y: 80, scale: 0.8 },
                { type: 'cloud', x: 700, y: 120, scale: 0.5 },
                // Add decorative elements
                { type: 'bush', x: 200, y: 520, scale: 0.7 },
                { type: 'bush', x: 500, y: 530, scale: 0.6 },
                { type: 'flower', x: 250, y: 540, scale: 0.8 },
                { type: 'flower', x: 550, y: 545, scale: 0.7 },
                { type: 'flower', x: 800, y: 535, scale: 0.9 }
            ];
            
            backgroundElements.forEach(element => {
                const bgElement = gameScene.createGameObject(`Background_${element.type}_${element.x}`)
                    .at(element.x, element.y)
                    .build();
                
                const svgRenderer = new SVGSpriteRenderer(element.type, 
                    element.type === 'mountain' ? 120 * element.scale : 
                    element.type === 'tree' ? 40 * element.scale : 
                    element.type === 'cloud' ? 80 * element.scale :
                    element.type === 'bush' ? 24 * element.scale :
                    element.type === 'flower' ? 16 * element.scale : 80 * element.scale,
                    element.type === 'mountain' ? 80 * element.scale : 
                    element.type === 'tree' ? 60 * element.scale : 
                    element.type === 'cloud' ? 40 * element.scale :
                    element.type === 'bush' ? 16 * element.scale :
                    element.type === 'flower' ? 16 * element.scale : 40 * element.scale
                );
                bgElement.addComponent(svgRenderer);
                
                // Set background layer
                svgRenderer.layer = -1; // Background layer
            });
        }
        
        function createLevel1() {
            // Add background elements
            createBackgroundElements();
            
            // Ground platforms
            createPlatform(0, 550, 1000, 50, '#2c3e50');
            createPlatform(200, 450, 200, 20, '#34495e');
            createPlatform(500, 350, 150, 20, '#34495e');
            createPlatform(750, 250, 200, 20, '#34495e');
            
            // Floating platforms
            createPlatform(300, 200, 100, 20, '#7f8c8d');
            createPlatform(600, 150, 120, 20, '#7f8c8d');
            
            // Enemies
            createEnemy(250, 420, 'patrol', 80);
            createEnemy(550, 320, 'patrol', 60);
            createEnemy(800, 220, 'chase', 120);
            
            // Collectibles
            createCollectible(350, 170, 50, 'coin');
            createCollectible(650, 120, 50, 'coin');
            createCollectible(850, 200, 100, 'gem');
            createCollectible(450, 320, 50, 'coin');
            createCollectible(900, 220, 50, 'coin');
        }
        
        function createLevel2() {
            // Add background elements
            createBackgroundElements();
            
            // More complex platform layout
            createPlatform(0, 550, 200, 50, '#2c3e50');
            createPlatform(300, 550, 200, 50, '#2c3e50');
            createPlatform(600, 550, 400, 50, '#2c3e50');
            
            // Multi-level platforms
            createPlatform(100, 450, 150, 20, '#34495e');
            createPlatform(350, 400, 100, 20, '#34495e');
            createPlatform(550, 350, 200, 20, '#34495e');
            createPlatform(150, 300, 120, 20, '#34495e');
            createPlatform(400, 250, 150, 20, '#34495e');
            createPlatform(700, 200, 100, 20, '#34495e');
            
            // Moving platforms
            createMovingPlatform(250, 500, 100, 60, 'horizontal');
            createMovingPlatform(800, 400, 100, 80, 'vertical');
            
            // More enemies with different behaviors
            createEnemy(120, 420, 'jump', 100);
            createEnemy(400, 370, 'patrol', 90);
            createEnemy(600, 320, 'chase', 150);
            createEnemy(450, 220, 'patrol', 70);
            
            // Hazards
            createHazard(500, 530, 20, 20);
            createHazard(520, 530, 20, 20);
            createHazard(540, 530, 20, 20);
            
            // More collectibles
            createCollectible(175, 270, 50, 'coin');
            createCollectible(475, 220, 75, 'gem');
            createCollectible(750, 170, 50, 'coin');
            createCollectible(350, 370, 50, 'coin');
            createCollectible(650, 320, 50, 'coin');
            createCollectible(850, 350, 100, 'gem');
        }
        
        function createLevel3() {
            // Add background elements
            createBackgroundElements();
            
            // Challenge level with complex layout
            createPlatform(0, 550, 150, 50, '#2c3e50');
            createPlatform(250, 550, 150, 50, '#2c3e50');
            createPlatform(500, 550, 150, 50, '#2c3e50');
            createPlatform(750, 550, 250, 50, '#2c3e50');
            
            // Challenging jumps
            createPlatform(50, 400, 80, 20, '#34495e');
            createPlatform(200, 300, 60, 20, '#34495e');
            createPlatform(350, 450, 80, 20, '#34495e');
            createPlatform(500, 350, 100, 20, '#34495e');
            createPlatform(650, 250, 80, 20, '#34495e');
            createPlatform(800, 150, 120, 20, '#34495e');
            
            // Multiple moving platforms
            createMovingPlatform(150, 450, 80, 100, 'vertical');
            createMovingPlatform(600, 400, 120, 80, 'horizontal');
            createMovingPlatform(300, 200, 100, 60, 'vertical');
            
            // Many enemies
            createEnemy(80, 370, 'chase', 120);
            createEnemy(230, 270, 'jump', 150);
            createEnemy(380, 420, 'patrol', 100);
            createEnemy(550, 320, 'chase', 180);
            createEnemy(680, 220, 'jump', 130);
            
            // More hazards
            createHazard(180, 530, 20, 20);
            createHazard(200, 530, 20, 20);
            createHazard(220, 530, 20, 20);
            createHazard(420, 530, 20, 20);
            createHazard(440, 530, 20, 20);
            createHazard(460, 530, 20, 20);
            createHazard(480, 530, 20, 20);
            
            // High-value collectibles
            createCollectible(80, 370, 75, 'gem');
            createCollectible(230, 270, 50, 'coin');
            createCollectible(550, 320, 100, 'gem');
            createCollectible(710, 220, 75, 'gem');
            createCollectible(860, 120, 150, 'gem');
            createCollectible(380, 420, 50, 'coin');
            createCollectible(330, 170, 100, 'gem');
        }

        // ==================== ENHANCED GAME OBJECT CREATION FUNCTIONS ====================
        
        function createPlatform(x, y, width, height, color = '#34495e') {
            const platform = gameScene.createGameObject(`Platform_${x}_${y}`)
                .at(x, y)
                .withCollider('box', width, height, false, 'Platform')
                .build();
            
            // Add SVG sprite renderer
            const svgRenderer = new SVGSpriteRenderer('platform', width, height);
            platform.addComponent(svgRenderer);
            
            // Ensure platform doesn't have a Rigidbody (should be static)
            const rigidbody = platform.getComponent(GameEngine.Rigidbody);
            if (rigidbody) {
                platform.removeComponent(rigidbody);
            }
            
            platforms.push(platform);
            return platform;
        }
        
        function createMovingPlatform(x, y, width, height, direction = 'horizontal') {
            const platform = gameScene.createGameObject(`MovingPlatform_${x}_${y}`)
                .at(x, y)
                .withCollider('box', width, height, false, 'Platform')
                .build();
            
            // Add SVG sprite renderer for moving platform
            const svgRenderer = new SVGSpriteRenderer('moving-platform', width, height);
            platform.addComponent(svgRenderer);
            
            // Ensure moving platform doesn't have a Rigidbody (should be kinematic)
            const rigidbody = platform.getComponent(GameEngine.Rigidbody);
            if (rigidbody) {
                platform.removeComponent(rigidbody);
            }
            
            platform.addComponent(new MovingPlatform(150, 80, direction));
            platforms.push(platform);
            return platform;
        }
        
        function createEnemy(x, y, type = 'patrol', speed = 100) {
            let enemy;
            
            if (type === 'jump') {
                // Jumping enemies need physics for gravity
                enemy = gameScene.createGameObject(`Enemy_${x}_${y}`)
                    .at(x, y)
                    .withCollider('box', 24, 24, false, 'Enemy')
                    .withDynamicBody(0.8, 1.0)
                    .build();
            } else {
                // Patrol and chase enemies move via script, no physics needed
                enemy = gameScene.createGameObject(`Enemy_${x}_${y}`)
                    .at(x, y)
                    .withCollider('box', 24, 24, false, 'Enemy')
                    .build();
            }
            
            // Add SVG sprite renderer for enemy
            const svgRenderer = new SVGSpriteRenderer('enemy', 24, 24);
            enemy.addComponent(svgRenderer);
            
            enemy.addComponent(new EnemyAI(type, speed));
            enemies.push(enemy);
            return enemy;
        }
        
        function createCollectible(x, y, value = 50, type = 'coin') {
            const size = type === 'gem' ? 24 : 20;
            const collectible = gameScene.createGameObject(`Collectible_${x}_${y}`)
                .at(x, y)
                .withCollider('box', size, size, true, 'Collectible')
                .build();
            
            // Add SVG sprite renderer for collectible
            const svgRenderer = new SVGSpriteRenderer(type, size, size);
            collectible.addComponent(svgRenderer);
            
            collectible.addComponent(new Collectible(value, type));
            collectibles.push(collectible);
            return collectible;
        }
        
        function createHazard(x, y, width = 24, height = 24) {
            const hazard = gameScene.createGameObject(`Hazard_${x}_${y}`)
                .at(x, y)
                .withCollider('box', width, height, true, 'Hazard')
                .build();
            
            // Add SVG sprite renderer for hazard
            const svgRenderer = new SVGSpriteRenderer('hazard', width, height);
            hazard.addComponent(svgRenderer);
            
            // Add damage component
            hazard.addComponent(new class extends GameEngine.Component {
                onCollisionEnter(other) {
                    const playerComponent = other.getComponent(AdvancedPlatformerPlayer);
                    if (playerComponent) {
                        playerComponent.takeDamage();
                    }
                }
            });
            
            hazards.push(hazard);
            return hazard;
        }



        // ==================== PARTICLE SYSTEM ====================
        
        // Object pool for particles to improve performance
        class ParticlePool {
            constructor(maxSize = 100) {
                this.pool = [];
                this.maxSize = maxSize;
                this.activeParticles = [];
            }
            
            get() {
                if (this.pool.length > 0) {
                    return this.pool.pop();
                }
                return null;
            }
            
            return(particle) {
                if (this.pool.length < this.maxSize) {
                    this.pool.push(particle);
                }
            }
            
            cleanup() {
                this.activeParticles = this.activeParticles.filter(particle => {
                    if (!particle || !particle.gameObject || !particle.gameObject.active) {
                        if (particle) {
                            this.return(particle);
                        }
                        return false;
                    }
                    return true;
                });
            }
        }
        
        const particlePool = new ParticlePool(200);
        
        function createCollectEffect(position, type) {
            const color = type === 'gem' ? '#ff00ff' : '#ffff00';
            for (let i = 0; i < 8; i++) {
                const particle = gameScene.createGameObject(`CollectParticle_${Date.now()}_${i}`)
                    .at(position.x, position.y)
                    .build();
                
                // Create sparkle particle
                const sparkleSVG = `
                    <svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="3,0 3.5,2.5 6,3 3.5,3.5 3,6 2.5,3.5 0,3 2.5,2.5" fill="${color}" stroke="#ffffff" stroke-width="0.3"/>
                    </svg>
                `;
                
                const svgRenderer = new SVGSpriteRenderer('sparkle', 6, 6);
                svgRenderer.svgAsset = sparkleSVG;
                svgRenderer.loadSVG = async function() {
                    this.canvas = await this.svgManager.createImageFromSVG(sparkleSVG, 6, 6);
                };
                svgRenderer.loadSVG();
                
                particle.addComponent(svgRenderer);
                
                const rigidbody = particle.getComponent(GameEngine.Rigidbody);
                if (rigidbody) {
                    const angle = (i / 8) * Math.PI * 2;
                    rigidbody.velocity = new GameEngine.Vector2(
                        Math.cos(angle) * 120,
                        Math.sin(angle) * 120
                    );
                }
                
                // Auto-destroy after 1.0 seconds
                setTimeout(() => {
                    if (particle && particle.destroy) {
                        particle.destroy();
                    }
                }, 1000);
                
                particles.push(particle);
            }
        }
        
        function createJumpParticles(position) {
            for (let i = 0; i < 8; i++) {
                const particle = gameScene.createGameObject(`JumpParticle_${Date.now()}_${i}`)
                    .at(position.x + (Math.random() - 0.5) * 20, position.y + 10)
                    .build();
                
                // Create star-shaped particle
                const starSVG = `
                    <svg width="8" height="8" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="4,0 5,3 8,4 5,5 4,8 3,5 0,4 3,3" fill="#ffffff" stroke="#f0f0f0" stroke-width="0.5"/>
                    </svg>
                `;
                
                const svgRenderer = new SVGSpriteRenderer('star', 8, 8);
                svgRenderer.svgAsset = starSVG;
                svgRenderer.loadSVG = async function() {
                    this.canvas = await this.svgManager.createImageFromSVG(starSVG, 8, 8);
                };
                svgRenderer.loadSVG();
                
                particle.addComponent(svgRenderer);
                
                const rigidbody = particle.getComponent(GameEngine.Rigidbody);
                if (rigidbody) {
                    rigidbody.velocity = new GameEngine.Vector2(
                        (Math.random() - 0.5) * 150,
                        -Math.random() * 250
                    );
                }
                
                // Auto-destroy after 1.2 seconds
                setTimeout(() => {
                    if (particle && particle.destroy) {
                        particle.destroy();
                    }
                }, 1200);
                
                particles.push(particle);
            }
        }
        
        function createDashParticles(position) {
            for (let i = 0; i < 12; i++) {
                const particle = gameScene.createGameObject(`DashParticle_${Date.now()}_${i}`)
                    .at(position.x + (Math.random() - 0.5) * 30, position.y + (Math.random() - 0.5) * 20)
                    .build();
                
                // Create lightning bolt particle
                const lightningSVG = `
                    <svg width="6" height="6" viewBox="0 0 6 6" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="3,0 2,2 4,3 2,4 3,6 4,4 2,3" fill="#00ffff" stroke="#0080ff" stroke-width="0.5"/>
                    </svg>
                `;
                
                const svgRenderer = new SVGSpriteRenderer('lightning', 6, 6);
                svgRenderer.svgAsset = lightningSVG;
                svgRenderer.loadSVG = async function() {
                    this.canvas = await this.svgManager.createImageFromSVG(lightningSVG, 6, 6);
                };
                svgRenderer.loadSVG();
                
                particle.addComponent(svgRenderer);
                
                const rigidbody = particle.getComponent(GameEngine.Rigidbody);
                if (rigidbody) {
                    rigidbody.velocity = new GameEngine.Vector2(
                        (Math.random() - 0.5) * 200,
                        (Math.random() - 0.5) * 200
                    );
                }
                
                // Auto-destroy after 0.6 seconds
                setTimeout(() => {
                    if (particle && particle.destroy) {
                        particle.destroy();
                    }
                }, 600);
                
                particles.push(particle);
            }
        }
        
        function createExplosionParticles(position) {
            for (let i = 0; i < 15; i++) {
                const particle = gameScene.createGameObject(`ExplosionParticle_${Date.now()}_${i}`)
                    .at(position.x + (Math.random() - 0.5) * 40, position.y + (Math.random() - 0.5) * 40)
                    .build();
                
                // Create fire particle
                const fireSVG = `
                    <svg width="8" height="8" viewBox="0 0 8 8" xmlns="http://www.w3.org/2000/svg">
                        <polygon points="4,0 6,4 4,8 2,4" fill="#ff4444" stroke="#cc0000" stroke-width="0.5"/>
                        <polygon points="4,1 5,4 4,7 3,4" fill="#ff6666"/>
                    </svg>
                `;
                
                const svgRenderer = new SVGSpriteRenderer('fire', 8, 8);
                svgRenderer.svgAsset = fireSVG;
                svgRenderer.loadSVG = async function() {
                    this.canvas = await this.svgManager.createImageFromSVG(fireSVG, 8, 8);
                };
                svgRenderer.loadSVG();
                
                particle.addComponent(svgRenderer);
                
                const rigidbody = particle.getComponent(GameEngine.Rigidbody);
                if (rigidbody) {
                    rigidbody.velocity = new GameEngine.Vector2(
                        (Math.random() - 0.5) * 350,
                        (Math.random() - 0.5) * 350
                    );
                }
                
                // Auto-destroy after 1.8 seconds
                setTimeout(() => {
                    if (particle && particle.destroy) {
                        particle.destroy();
                    }
                }, 1800);
                
                particles.push(particle);
            }
        }

        // ==================== GAME LOGIC ====================
        
        function createPlayer() {
            player = gameScene.createGameObject('Player')
                .at(gameState.playerStartX, gameState.playerStartY)
                .withCollider('box', 32, 48, false, 'Player')
                .withDynamicBody(1.0, 1.0)
                .build();
            
            // Add SVG sprite renderer for player
            const svgRenderer = new SVGSpriteRenderer('player', 32, 48);
            player.addComponent(svgRenderer);
            
            // Configure the Rigidbody for better platformer physics
            const rigidbody = player.getComponent(GameEngine.Rigidbody);
            if (rigidbody) {
                rigidbody.drag = 0.98; // Slightly more responsive
                rigidbody.gravity = new GameEngine.Vector2(0, 1200); // Stronger gravity for snappier feel
            }
            
            player.addComponent(new AdvancedPlatformerPlayer({
                speed: 250,
                jumpForce: 500,
                gravity: 1200,
                onJump: () => {
                    createJumpParticles(player.transform.position);
                    audioManager.play('jump');
                },
                onLanding: () => {}
            }));
            
            return player;
        }
        
        function setupPhysics() {
            // Set up collision rules
            engine.physicsEngine.setCollisionRule('Player', 'Platform', true);
            engine.physicsEngine.setCollisionRule('Player', 'Enemy', true);
            engine.physicsEngine.setCollisionRule('Player', 'Collectible', true);
            engine.physicsEngine.setCollisionRule('Player', 'Hazard', true);
            engine.physicsEngine.setCollisionRule('Enemy', 'Platform', true);
            engine.physicsEngine.setCollisionRule('Enemy', 'Enemy', false);
        }
        
        function setupCamera() {
            camera = gameScene.camera;
            camera.follow(player);
            camera.setBounds(-100, -100, 1200, 800);
        }
        
        function clearLevel() {
            // Remove all level objects
            [...platforms, ...enemies, ...collectibles, ...hazards].forEach(obj => {
                if (obj && obj.destroy) {
                    obj.destroy();
                }
            });
            
            platforms = [];
            enemies = [];
            collectibles = [];
            hazards = [];
        }
        
        function checkLevelComplete() {
            const remainingCollectibles = collectibles.filter(c => c && !c.getComponent(Collectible).collected);
            
            if (remainingCollectibles.length === 0) {
                gameState.level++;
                
                if (gameState.level > gameState.maxLevel) {
                    // Game completed!
                    gameState.score += 1000; // Bonus for completing game
                    updateUI();
                    setTimeout(() => {
                        alert('Congratulations! You completed all levels!\nFinal Score: ' + gameState.score);
                        restartGame();
                    }, 1000);
                } else {
                    // Next level
                    gameState.score += 500; // Level completion bonus
                    updateUI();
                    setTimeout(() => {
                        createLevel(gameState.level);
                        if (player) {
                            player.getComponent(AdvancedPlatformerPlayer).respawnPlayer();
                        }
                    }, 1000);
                }
            }
        }
        
        function updateUI() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('lives').textContent = gameState.lives;
            document.getElementById('level').textContent = gameState.level;
        }
        
        function endGame() {
            gameState.gameOver = true;
            document.getElementById('final-score').textContent = gameState.score;
            document.getElementById('game-over-screen').style.display = 'block';
        }
        
        function restartGame() {
            // Reset game state
            gameState = {
                score: 0,
                lives: 3,
                level: 1,
                gameOver: false,
                playerStartX: 100,
                playerStartY: 400,
                maxLevel: 3
            };
            
            // Hide game over screen
            document.getElementById('game-over-screen').style.display = 'none';
            
            // Clear and recreate level
            clearLevel();
            createLevel(1);
            
            // Reset player
            if (player) {
                player.getComponent(AdvancedPlatformerPlayer).respawnPlayer();
                player.getComponent(AdvancedPlatformerPlayer).invulnerable = false;
                player.getComponent(GameEngine.SpriteRenderer).alpha = 1.0;
            }
            
            updateUI();
        }

        // ==================== INPUT HANDLING ====================
        
        function updatePerformanceStats() {
            const stats = engine.getPerformanceStats();
            document.getElementById('fps').textContent = stats.fps || 0;
            document.getElementById('object-count').textContent = stats.activeObjects || 0;
            document.getElementById('collision-count').textContent = stats.collisionChecks || 0;
        }
        
        function setupInputHandling() {
            // Create input handler component that checks for key presses each frame
            const inputHandler = new class extends GameEngine.Component {
                constructor() {
                    super();
                    this.previousKeys = new Map();
                    this.frameCount = 0;
                }
                
                update(deltaTime) {
                    // Check for key presses (not held down)
                    if (this.isKeyJustPressed('KeyR') && !gameState.gameOver) {
                        restartGame();
                    }
                    
                    if (this.isKeyJustPressed('KeyP')) {
                        if (engine.gameLoop.isRunning) {
                            engine.pause();
                        } else {
                            engine.resume();
                        }
                    }
                    
                    if (this.isKeyJustPressed('KeyD')) {
                        engine.setDebugMode(!GameEngine.Debug.enabled);
                    }
                    
                    if (this.isKeyJustPressed('KeyM')) {
                        const soundEnabled = audioManager.toggle();
                        console.log(`Sound ${soundEnabled ? 'enabled' : 'disabled'}`);
                    }
                    
                    if (this.isKeyJustPressed('KeyP')) {
                        const perfStats = document.getElementById('performance-stats');
                        perfStats.style.display = perfStats.style.display === 'none' ? 'block' : 'none';
                    }
                    
                    // Update previous keys state
                    this.updatePreviousKeys();
                    
                    // Update performance stats every 10 frames
                    if (this.frameCount % 10 === 0) {
                        updatePerformanceStats();
                    }
                    this.frameCount++;
                }
                
                isKeyJustPressed(keyCode) {
                    const currentlyPressed = engine.inputManager.isKeyDown(keyCode);
                    const wasPressed = this.previousKeys.get(keyCode) || false;
                    return currentlyPressed && !wasPressed;
                }
                
                updatePreviousKeys() {
                    // Store current key states for next frame
                    const keysToCheck = ['KeyR', 'KeyP', 'KeyD', 'KeyM'];
                    keysToCheck.forEach(key => {
                        this.previousKeys.set(key, engine.inputManager.isKeyDown(key));
                    });
                }
            };
            
            // Add input handler to a persistent game object
            const inputGameObject = gameScene.createGameObject('InputHandler').build();
            inputGameObject.addComponent(inputHandler);
        }

        // ==================== INITIALIZATION ====================
        
        function initializeGame() {
            try {
                // Show start prompt
                document.getElementById('start-prompt').style.display = 'block';
                
                // Wait for user interaction
                document.addEventListener('click', function startGame() {
                    document.getElementById('start-prompt').style.display = 'none';
                    document.removeEventListener('click', startGame);
                    
                    // Initialize audio context on user interaction
                    audioManager.createAudioContext();
                    
                    // Create player
                    createPlayer();
                    
                    // Setup systems
                    setupPhysics();
                    setupCamera();
                    setupInputHandling();
                    
                    // Create first level
                    createLevel(1);
                    
                    // Update UI
                    updateUI();
                    
                    // Add scene to manager and start
                    engine.sceneManager.add('game', gameScene);
                    engine.sceneManager.load('game');
                    engine.start();
                    
                    console.log('Advanced Platformer Game Initialized!');
                    console.log('Controls: Arrow Keys = Move, Spacebar = Jump, X = Double Jump, Z = Dash');
                    console.log('Additional: R = Restart, P = Pause, D = Debug Mode, M = Toggle Sound');
                }, { once: true });
                
            } catch (error) {
                console.error('Error initializing game:', error);
                document.getElementById('start-prompt').innerHTML = '<h3>Error Loading Game</h3><p>Check console for details</p>';
            }
        }

        // Start the game when page loads
        function waitForGameEngine() {
            if (typeof GameEngine !== 'undefined' && GameEngine.SeedFrames) {
                console.log('GameEngine loaded successfully');
                console.log('Available components:', Object.keys(GameEngine));
                initializeGame();
            } else {
                console.log('Waiting for GameEngine to load...', typeof GameEngine);
                setTimeout(waitForGameEngine, 100);
            }
        }
        
        window.addEventListener('load', () => {
            setTimeout(waitForGameEngine, 100);
        });

        // Global restart function for button
        window.restartGame = restartGame;
    </script>
</body>
</html>